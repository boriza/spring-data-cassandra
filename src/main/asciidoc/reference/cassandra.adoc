[[cassandra.core]]
= Cassandra support

The Cassandra support contains a wide range of features which are summarized below.

* Spring configuration support using Java-based `@Configuration` classes or the XML namespace to create
a Cassandra instance with replica sets using the driver.
* CassandraTemplate helper class that increases productivity by handling common Cassandra operations properly.
Includes integrated object mapping between CQL Tables and POJOs.
* Exception translation into Spring's portable http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#dao-exceptions[Data Access Exception Hierarchy].
* Feature rich object mapping integrated with Spring's http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#core-convert[Conversion Service].
* Annotation-based mapping metadata but extensible to support other metadata formats.
* Persistence and mapping lifecycle events.
* Java-based Query, Criteria, and Update DSLs.
* Automatic implementation of `Repository` interfaces including support for custom finder methods.

For most data oriented tasks you will use the `CassandraTemplate` or the `Repository` support, which leverage the
rich mapping functionality. `CassandraTemplate` is commonly used to increment counters or perform ad-hoc CRUD
operations. `CassandraTemplate` also provides callback methods making it easy to get a hold of low-level API objects
such as `com.datastax.driver.core.Session` allowing you to communicate directly with Cassandra. Spring Data Cassandra
uses consistent naming conventions on objects in various APIs to those found in the DataStax Java Driver so that they
are familiar and so you can  map your existing knowledge onto the Spring APIs.


[[cassandra.modules]]
== Spring CQL and Spring Data Cassandra modules

Spring Data for Apache Cassandra comes with two modules: Spring CQL and Spring Data Cassandra.

The value-add provided by the Spring Data for Apache Cassandra abstraction is perhaps best shown by the sequence of actions outlined in the table below. The table shows what actions Spring will take care of and which actions are the responsibility of you, the application developer.

[[cassandra.modules.who-does-what]]
.Spring CQL - who does what?
|===
| Action| Spring| You

| Define connection parameters.
|
| X

| Open the connection.
| X
|

| Specify the CQL statement.
|
| X

| Declare parameters and provide parameter values
|
| X

| Prepare and execute the statement.
| X
|

| Set up the loop to iterate through the results (if any).
| X
|

| Do the work for each iteration.
|
| X

| Process any exception.
| X
|

| Close the Session.
| X
|
|===

Spring CQL takes care of all the low-level details that can make Cassandra and CQL such a
tedious API to develop with. Spring Data Cassandra adds object mapping, schema generation and repository support to the featureset.


[[cassandra.choose-style]]
=== Choosing an approach for Cassandra database access
You can choose among several approaches to form the basis for your Cassandra database access. Spring's support for Apache Cassandra comes in different flavors. Once you start using one of these approaches, you can still mix and match to include a feature from a different approach.

* __CqlTemplate__ is the classic Spring CQL approach and the most popular. This  "lowest level" approach and all others use a `CqlTemplate` under the covers.
* __CassandraTemplate__ wraps a `CqlTemplate` to provide result to object mapping and the use of SELECT, INSERT, UPDATE and DELETE methods instead of writing CQL statements. This approach provides better documentation and ease of use.
* __Repository Abstraction__  allows you to create repository declarations in your data access layer. The goal of Spring Data repository abstraction is to significantly reduce the amount of boilerplate code required to implement data access layers for various persistence stores.


[[cassandra.getting-started]]
== Getting Started

Spring Apache Cassandra support requires Cassandra 2.1 or higher, Datastax Java Driver 3.0 or higher and Java SE 6 or higher. An easy way to bootstrap setting up a working environment is to create a Spring based project in http://spring.io/tools/sts[STS].

First you need to set up a running Apache Cassandra server. Refer to the http://cassandra.apache.org/doc/latest/getting_started/index.html[Apache Cassandra Quick Start guide] for an explanation on how to startup Apache Cassandra. Once installed starting Cassandra is typically a matter of executing the following command: `CASSANDRA_HOME/bin/cassandra -f`

To create a Spring project in STS go to File -> New -> Spring Template Project -> Simple Spring Utility Project -> press Yes when prompted. Then enter a project and a package name such as org.spring.cassandra.example.

Then add the following to pom.xml dependencies section.
[source,xml,subs="verbatim,attributes"]
----
<dependencies>

  <!-- other dependencies omitted -->

  <dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-cassandra</artifactId>
    <version>{version}</version>
  </dependency>

</dependencies>
----

Also change the version of Spring in the pom.xml to be

[source,xml,subs="verbatim,attributes"]
----
<spring.framework.version>{springVersion}</spring.framework.version>
----

If using a milestone release instead of a GA release, you will also need to add the location of the Spring Milestone repository for maven to your pom.xml which is at the same level of your <dependencies/> element

[source,xml]
----
<repositories>
  <repository>
    <id>spring-milestone</id>
    <name>Spring Maven MILESTONE Repository</name>
    <url>http://repo.spring.io/libs-milestone</url>
  </repository>
</repositories>
----

The repository is also http://repo.spring.io/milestone/org/springframework/data/[browseable here].

You can also browse the Spring repositories https://repo.spring.io/webapp/#/home[here].

Now we will create a simple Java application that stores and reads a domain object to/from Cassandra.

First, create a simple domain object class to persist.

[source,java]
----
package org.spring.data.cassandra.example;

import org.springframework.data.cassandra.mapping.PrimaryKey;
import org.springframework.data.cassandra.mapping.Table;

@Table
public class Person {

  @PrimaryKey
  private final String id;

  private final String name;
  private final int age;

  public Person(String id, String name, int age) {
    this.id = id;
    this.name = name;
    this.age = age;
  }

  public String getId() {
    return id;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  @Override
  public String toString() {
    return String.format("{ @type = %1$s, id = %2$s, name = %3$s, age = %4$d }",
      getClass().getName(), getId(), getName(), getAge());
  }
}
----

Next, create the main application to run.

[source,java]
----
package org.spring.data.cassandra.example;

import java.io.Closeable;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.cassandra.core.CassandraOperations;
import org.springframework.data.cassandra.core.CassandraTemplate;

import com.datastax.driver.core.Cluster;
import com.datastax.driver.core.Session;
import com.datastax.driver.core.querybuilder.QueryBuilder;
import com.datastax.driver.core.querybuilder.Select;

public class CassandraApplication {

  private static final Logger LOGGER = LoggerFactory.getLogger(CassandraApplication.class);

  protected static Person newPerson(String name, int age) {
    return newPerson(UUID.randomUUID().toString(), name, age);
  }

  protected static Person newPerson(String id, String name, int age) {
    return new Person(id, name, age);
  }

  public static void main(String[] args) {

    Cluster cluster = Cluster.builder().addContactPoints("localhost").build();
    Session session = cluster.connect("mykeyspace");

    CassandraOperations template = new CassandraTemplate(session);

    Person jonDoe = template.insert(newPerson("Jon Doe", 40));

    Select selectStatement = QueryBuilder.select().from("person");
    selectStatement.where(QueryBuilder.eq("id", jonDoe.getId()));

    LOGGER.info(template.queryForObject(selectStatement, Person.class).getId());

    template.truncate("person");
    session.close();
    cluster.close();
  }
}
----

Even in this simple example, there are a few things to observe.

* You can create an instance of `CassandraTemplate` with a Cassandra `Session`, derived from a `Cluster`.
* You must annotate your POJO as a Cassandra `@Table` and also annotate the `@PrimaryKey`. Optionally, you can
override these mapping names to match your Cassandra database table and column names.
* You can either use a CQL String or the DataStax `QueryBuilder` API to construct you queries.

[[cassandra.examples-repo]]
== Examples Repository

There is a https://github.com/spring-projects/spring-data-examples[Github repository with several examples] that you can download and play around with to get a feel for how the library works.

[[cassandra.connectors]]
== Connecting to Cassandra with Spring

One of the first tasks when using Apache Cassandra and Spring is to create a `com.datastax.driver.core.Session` object using the IoC container. There are two main ways to do this, either using Java based bean metadata or XML based bean metadata. These are discussed in the following sections.

NOTE: For those not familiar with how to configure the Spring container using Java based bean metadata instead of XML based metadata see the high level introduction in the reference docs http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html#new-java-configuration[here ] as well as the detailed documentation http://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/html/beans.html#beans-java-instantiating-container[ here].

[[cassandra.cassandra-java-config]]
=== Registering a Session instance using Java based metadata

An example of using Java based bean metadata to register an instance of a `com.datastax.driver.core.Session` is shown below

.Registering a com.datastax.driver.core.Session object using Java based bean metadata
====
[source,java]
----
@Configuration
public class AppConfig {

  /*
   * Use the standard Cassandra driver API to create a com.datastax.driver.core.Session instance.
   */
  public @Bean Session session() {
    Cluster cluster = Cluster.builder().addContactPoints("localhost").build();
    return cluster.connect("mykeyspace");
  }
}
----
====

This approach allows you to use the standard `com.datastax.driver.core.Session` API that you may already be used to using.

An alternative is to register an instance of `com.datastax.driver.core.Session` instance with the container using Spring's `CassandraCqlSessionFactoryBean` and `CassandraCqlClusterFactoryBean`. As compared to instantiating a `com.datastax.driver.core.Session` instance directly, the `FactoryBean` approach has the added advantage of also providing the container with an ExceptionTranslator implementation that translates Cassandra exceptions to exceptions in Spring's portable `DataAccessException` hierarchy for data access classes annotated. This hierarchy and use of `@Repository` is described in http://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/html/dao.html[Spring's DAO support features].

An example of a Java based bean metadata that supports exception translation on `@Repository` annotated classes is shown below:

.Registering a com.datastax.driver.core.Session object using Spring's CassandraCqlSessionFactoryBean and enabling Spring's exception translation support
====
[source,java]
----
@Configuration
public class AppConfig {

  /*
   * Factory bean that creates the com.datastax.driver.core.Session instance
   */
  public @Bean CassandraCqlClusterFactoryBean cluster() {

    CassandraCqlClusterFactoryBean cluster = new CassandraCqlClusterFactoryBean();
    cluster.setContactPoints("localhost");

    return cluster;
  }

  /*
   * Factory bean that creates the com.datastax.driver.core.Session instance
   */
   public @Bean CassandraCqlSessionFactoryBean session() {

    CassandraCqlSessionFactoryBean session = new CassandraCqlSessionFactoryBean();
    session.setCluster(cluster().getObject());
    session.setKeyspaceName("mykeyspace");

    return session;
  }
}
----
====

Using `CassandraTemplate` with object mapping and repository support requires a `CassandraTemplate`, `CassandraMappingContext`, `CassandraConverter` and enabling repository support.

.Registering components to configure object mapping and repository support
====
[source,java]
----
@Configuration
@EnableCassandraRepositories(basePackages = { "org.spring.cassandra.example.repo" })
public class CassandraConfig {

  @Bean
  public CassandraClusterFactoryBean cluster() {

    CassandraClusterFactoryBean cluster = new CassandraClusterFactoryBean();
    cluster.setContactPoints("localhost");

    return cluster;
  }

  @Bean
  public CassandraMappingContext mappingContext() {

    BasicCassandraMappingContext mappingContext =  new BasicCassandraMappingContext();
    mappingContext.setUserTypeResolver(new SimpleUserTypeResolver(cluster().getObject(), "mykeyspace"));

    return mappingContext;
  }

  @Bean
  public CassandraConverter converter() {
    return new MappingCassandraConverter(mappingContext());
  }

  @Bean
  public CassandraSessionFactoryBean session() throws Exception {

    CassandraSessionFactoryBean session = new CassandraSessionFactoryBean();
    session.setCluster(cluster().getObject());
    session.setKeyspaceName("mykeyspace");
    session.setConverter(converter());
    session.setSchemaAction(SchemaAction.NONE);

    return session;
  }

  @Bean
  public CassandraOperations cassandraTemplate() throws Exception {
    return new CassandraTemplate(session().getObject());
  }
}
----
====

Creating configuration classes registering Spring Data Cassandra components can get an exhausing challenge so Spring Data Cassandra comes with a prebuilt configuration support class. Classes extending from `AbstractCassandraConfiguration` will register beans for Spring Data Cassandra use. `AbstractCassandraConfiguration` lets you provide various configuration options such as initial entities, default query options, socket options, pooling options and much more. `AbstractCassandraConfiguration` will support you also with schema generation based on initial entities, if any provided. Extending from `AbstractCassandraConfiguration` requires you to at least provide the keyspace name by implementing the `getKeyspaceName` method.

.Registering Spring Data Cassandra beans using AbstractCassandraConfiguration
====
[source,java]
----
@Configuration
public class AppConfig extends AbstractCassandraConfiguration {

  /*
   * Provide a contact point to the configuration.
   */
  public String getContactPoints() {
    return "localhost";
  }

  /*
   * Provide a keyspace name to the configuration.
   */
  public getKeyspaceName() {
    return "mykeyspace";
  }
}
----
====

[[cassandra-connectors.xmlconfig]]
=== XML Configuration

[[cassandra-connectors.xmlconfig.ext_properties]]
==== Externalize Connection Properties

Create a properties file containing the information needed to connect to Cassandra. `contactpoints` and `keyspace`
are required fields; `port` has been added for clarity.

We will call this properties file, `cassandra.properties`.

[source]
----
cassandra.contactpoints=10.1.55.80,10.1.55.81
cassandra.port=9042
cassandra.keyspace=showcase
----

We will use Spring to load these properties into the Spring context in the next two examples.

==== Registering a Session instance using XML based metadata

While you can use Spring's traditional `<beans/>` XML namespace to register an instance of `com.datastax.driver.core.Session` with the container, the XML can be quite verbose as it is general purpose. XML namespaces are a better alternative to configuring commonly used objects such as the Session instance. The `cql` and `cassandra` namespaces allow you to create a Session instance.

To use the Mongo namespace elements you will need to reference the Mongo schema:

.XML schema to configure Cassandra using the `cql` namespace
====
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:cql="http://www.springframework.org/schema/data/cql"
          xmlns:context="http://www.springframework.org/schema/context"
          xsi:schemaLocation="http://www.springframework.org/schema/cql http://www.springframework.org/schema/cql/spring-cql-1.0.xsd
          http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

  <!-- Default bean name is 'cassandraCluster' -->
  <cql:cluster contact-points="localhost" port="9042">
    <cql:keyspace action="CREATE_DROP" name="mykeyspace" />
  </cql:cluster>

  <!-- Default bean name is 'cassandraSession' -->
  <cql:session keyspace-name="mykeyspace" />

</beans>
----
====

.XML schema to configure Cassandra using the `cassandra` namespace
====
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:cassandra="http://www.springframework.org/schema/data/cassandra"
          xmlns:context="http://www.springframework.org/schema/context"
          http://www.springframework.org/schema/data/cassandra http://www.springframework.org/schema/data/cassandra/spring-cassandra-1.0.xsd
          http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

  <!-- Default bean name is 'cassandraCluster' -->
  <cassandra:cluster contact-points="localhost" port="9042">
    <cassandra:keyspace action="CREATE_DROP" name="mykeyspace" />
  </cassandra:cluster>

  <!-- Default bean name is 'cassandraSession' -->
  <cass:session keyspace-name="${cassandra.keyspace}" schema-action="NONE" />

</beans>
----
====

NOTE: You may have noticed the slight difference between namespaces: `cql` and `cassandra`. Using the `cql` namespace is limited to low level CQL support while `cassandra` extends the `cql` namespace by object mapping and schema generation support.

The XML Configuration elements for a more advanced Cassandra configuration are shown below. These elements all use default bean names to keep the configuration code clean and readable.

While this example show how easy it is to configure Spring to connect to Cassandra, there are many other options. Basically, any option available with the DataStax Java Driver is also available in the Spring Data Cassandra configuration. This is including, but not limited to Authentication, Load Balancing Policies, Retry Policies and Pooling Options. All of the Spring Data Cassandra method names and XML elements are named exactly (or as close as possible) like the configuration options on the driver so mapping any existing driver configuration should be straight forward.

[source,xml]
----
<?xml version='1.0'?>
<beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:cassandra="http://www.springframework.org/schema/data/cassandra"
          xmlns:context="http://www.springframework.org/schema/context"
          http://www.springframework.org/schema/data/cassandra http://www.springframework.org/schema/data/cassandra/spring-cassandra-1.0.xsd
          http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

  <!-- Loads the properties into the Spring Context and uses them to fill 
    in placeholders in the bean definitions -->
  <context:property-placeholder location="classpath:cassandra.properties" />

  <!-- REQUIRED: The Cassandra Cluster -->
  <cassandra:cluster contact-points="${cassandra.contactpoints}"
    port="${cassandra.port}" />

  <!-- REQUIRED: The Cassandra Session, built from the Cluster, and attaching 
    to a keyspace -->
  <cassandra:session keyspace-name="${cassandra.keyspace}" />

  <!-- REQUIRED: The Default Cassandra Mapping Context used by CassandraConverter -->
  <cassandra:mapping>
    <cassandra:user-type-resolver keyspace-name="${cassandra.keyspace}" />
  </cassandra:mapping>

  <!-- REQUIRED: The Default Cassandra Converter used by CassandraTemplate -->
  <cassandra:converter />

  <!-- REQUIRED: The Cassandra Template is the building block of all Spring 
    Data Cassandra -->
  <cassandra:template id="cassandraTemplate" />

  <!-- OPTIONAL: If you are using Spring Data Cassandra Repositories, add 
    your base packages to scan here -->
  <cassandra:repositories base-package="org.spring.cassandra.example.repo" />

</beans>
----

[[cassandra-template]]
== Introduction to CassandraTemplate

The class `CassandraTemplate`, located in the package `org.springframework.data.cassandra`, is the central class of the Spring's Cassandra support providing a rich feature set to interact with the database. The template offers convenience operations to create, update, delete and query Cassandra and provides a mapping between your domain objects and Cassandra rows.

NOTE: Once configured, `CassandraTemplate` is thread-safe and can be reused across multiple instances.

The mapping between Cassandra rows and domain classes is done by delegating to an implementation of the interface `CassandraConverter`. Spring provides a default implementation, `MappingCassandraConverter`, but you can also write your own converter. Please refer to the section on <<mapping-chapter,Cassandra conversion>> for more detailed information.

The `CassandraTemplate` class implements the interface `CassandraOperations`. In as much as possible, the methods on `CassandraOperations` are named after methods available with Cassandra to make the API familiar to existing Cassandra developers who are used to Cassandra. For example, you will find methods such as "select", "insert", "delete", and "update". The design goal was to make it as easy as possible to transition between the use of the base Cassandra driver and `CassandraOperations`. A major difference in between the two APIs is that `CassandraOperations` can be passed domain objects instead of CQL and query objects.

NOTE: The preferred way to reference the operations on `CassandraTemplate` instance is via its interface `CassandraOperations`.

The default converter implementation used by `CassandraTemplate` is `MappingCassandraConverter`. While the `MappingCassandraConverter` can make use of additional metadata to specify the mapping of objects to rows it is also capable of converting objects that contain no additional metadata by using some conventions for the mapping of fields and table names. These conventions as well as the use of mapping annotations is explained in the <<mapping.chapter,Mapping chapter>>.

Another central feature of `CassandraTemplate` is exception translation of exceptions thrown in the Cassandra Java driver into Spring's portable Data Access Exception hierarchy. Refer to the section on <<cassandra.exception,exception translation>> for more information.

Now let's look at a examples of how to work with the `CassandraTemplate` in the context of the Spring container.

[[cassandra-template.instantiating]]
=== Instantiating CassandraTemplate

`CassandraTemplate` should always be configured as a Spring Bean, although we show an example above where you can instantiate it directly. But for the purposes of this being a Spring module, lets assume we are using the Spring Container.

`CassandraTemplate` is an implementation of `CassandraOperations`. You should always assign your `CassandraTemplate` to its interface definition, `CassandraOperations`.

There are 2 easy ways to get a `CassandraTemplate`, depending on how you load you Spring Application Context.

[float]
==== AutoWiring

[source,java]
----
@Autowired
private CassandraOperations cassandraOperations;
----

Like all Spring Autowiring, this assumes there is only one bean of type `CassandraOperations` in the `ApplicationContext`. If you have multiple `CassandraTemplate` beans (which will be the case if you are working with multiple keyspaces in the same project), use the `@Qualifier`annotation to designate which bean you want to Autowire.

[source,java]
----
@Autowired
@Qualifier("myTemplateBeanId")
private CassandraOperations cassandraOperations;
----

[float]
==== Bean Lookup with ApplicationContext

You can also just lookup the `CassandraTemplate` bean from the `ApplicationContext`.

[source,java]
----
CassandraOperations cassandraOperations = applicationContext.getBean("cassandraTemplate", CassandraOperations.class);
----

[[cassandra-template.save-update-remove]]
== Saving, Updating, and Removing Rows

`CassandraTemplate` provides a simple way for you to save, update, and delete your domain objects and map those objects to documents stored in Cassandra.

[[cassandra-template.id-handling]]
=== How the Composite Primary Key fields are handled in the mapping layer

Cassandra requires that you have at least 1 Partition Key field for a CQL Table. Alternately, you can have one or more Clustering Key fields. When your CQL Table has a composite Primary Key field you must create a @PrimaryKeyClass to define the structure of the composite PK. In this context, composite PK means one or more partition columns, or 1 partition column plus one or more clustering columns.

==== Simplest Composite Key

The simplest for of a Composite key is a key with one partition key and one clustering key. Here is an example of a CQL Table, and the corresponding POJOs that represent the table and it's composite key.

CQL Table defined in Cassandra

[source]
----
create table login_event(
  person_id text, 
  event_time timestamp,
  event_code int,
  ip_address text,
  primary key (person_id, event_time))
  with CLUSTERING ORDER BY (event_time DESC)
;
----

Class defining the *Composite Primary Key*. 

NOTE: PrimaryKeyClass must implement `Serializable` and provide implementation of `hashCode()` and `equals()` just like the example.

[source,java]
----
package org.spring.cassandra.example;

import java.io.Serializable;
import java.util.Date;

import org.springframework.cassandra.core.Ordering;
import org.springframework.cassandra.core.PrimaryKeyType;
import org.springframework.data.cassandra.mapping.PrimaryKeyClass;
import org.springframework.data.cassandra.mapping.PrimaryKeyColumn;

@PrimaryKeyClass
public class LoginEventKey implements Serializable {

  @PrimaryKeyColumn(name = "person_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
  private String personId;

  @PrimaryKeyColumn(name = "event_time", ordinal = 1, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.DESCENDING)
  private Date eventTime;

  public String getPersonId() {
    return personId;
  }

  public void setPersonId(String personId) {
    this.personId = personId;
  }

  public Date getEventTime() {
    return eventTime;
  }

  public void setEventTime(Date eventTime) {
    this.eventTime = eventTime;
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((eventTime == null) ? 0 : eventTime.hashCode());
    result = prime * result + ((personId == null) ? 0 : personId.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    LoginEventKey other = (LoginEventKey) obj;
    if (eventTime == null) {
      if (other.eventTime != null)
        return false;
    } else if (!eventTime.equals(other.eventTime))
      return false;
    if (personId == null) {
      if (other.personId != null)
        return false;
    } else if (!personId.equals(other.personId))
      return false;
    return true;
  }
}
----

Class defining the CQL Table, having the *Composite Primary Key* as an attribute and annotated as the `PrimaryKey`.

[source,java]
----
package org.spring.cassandra.example;

import org.springframework.data.cassandra.mapping.Column;
import org.springframework.data.cassandra.mapping.PrimaryKey;
import org.springframework.data.cassandra.mapping.Table;

@Table(value = "login_event")
public class LoginEvent {

  @PrimaryKey
  private LoginEventKey pk;

  @Column(value = "event_code")
  private int eventCode;

  @Column(value = "ip_address")
  private String ipAddress;

  public LoginEventKey getPk() {
    return pk;
  }

  public void setPk(LoginEventKey pk) {
    this.pk = pk;
  }

  public int getEventCode() {
    return eventCode;
  }

  public void setEventCode(int eventCode) {
    this.eventCode = eventCode;
  }

  public String getIpAddress() {
    return ipAddress;
  }

  public void setIpAddress(String ipAddress) {
    this.ipAddress = ipAddress;
  }

}
----

==== Complex Composite Primary Key

The annotations provided with Spring Data Cassandra can handle any key combination available in Cassandra. Here is one more example of a Composite Primary Key with 5 columns, 2 of which are a composite partition key, and the remaining 3 are ordered clustering keys. The getters/setters, hashCode and equals are omitted for brevity.

[source,java]
----
package org.spring.cassandra.example;

import java.io.Serializable;
import java.util.Date;

import org.springframework.cassandra.core.Ordering;
import org.springframework.cassandra.core.PrimaryKeyType;
import org.springframework.data.cassandra.mapping.PrimaryKeyClass;
import org.springframework.data.cassandra.mapping.PrimaryKeyColumn;

@PrimaryKeyClass
public class DetailedLoginEventKey implements Serializable {

  @PrimaryKeyColumn(name = "person_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
  private String personId;

  @PrimaryKeyColumn(name = "wks_id", ordinal = 1, type = PrimaryKeyType.PARTITIONED)
  private String workstationId;

  @PrimaryKeyColumn(ordinal = 2, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.ASCENDING)
  private Date application;

  @PrimaryKeyColumn(name = "event_code", ordinal = 3, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.ASCENDING)
  private Date eventCode;

  @PrimaryKeyColumn(name = "event_time", ordinal = 4, type = PrimaryKeyType.CLUSTERED, ordering = Ordering.DESCENDING)
  private Date eventTime;

  ...

}
----

[[cassandra-template.type-mapping]]
=== Type mapping

Spring Data Cassandra relies on the DataStax Java Driver type mapping component. This approach ensures that as types are added or changed, the Spring Data Cassandra module will continue to function without requiring changes. For more information on the DataStax CQL3 to Java Type mappings, please see their http://www.datastax.com/documentation/developer/java-driver/2.0/java-driver/reference/javaClass2Cql3Datatypes_r.html[Documentation here].

[[cassandra-template.save-insert]]
=== Methods for saving and inserting rows

==== Single records inserts

To insert one row at a time, there are many options. At this point you should already have a cassandraTemplate available to you so we will just how the relevant code for each section, omitting the template setup.

Insert a record with an annotated POJO.

[source,java]
----
cassandraOperations.insert(new Person("123123123", "Alison", 39));
----

Insert a row using the QueryBuilder.Insert object that is part of the DataStax Java Driver.

[source,java]
----
Insert insert = QueryBuilder.insertInto("person");
insert.setConsistencyLevel(ConsistencyLevel.ONE);
insert.value("id", "123123123");
insert.value("name", "Alison");
insert.value("age", 39);

cassandraOperations.execute(insert);
----

Then there is always the old fashioned way. You can write your own CQL statements.

[source,java]
----
String cql = "insert into person (id, name, age) values ('123123123', 'Alison', 39)";
   
cassandraOperations.execute(cql);
----

==== Multiple inserts for high speed ingestion

CQLOperations, which is extended by CassandraOperations is a lower level Template that you can use for just about anything you need to accomplish with Cassandra. CqlOperations includes several overloaded methods named `ingest()`.

Use these methods to pass a CQL String with Bind Markers, and your preferred flavor of data set (`Object[][]` and `List<List<T>>`).

The ingest method takes advantage of static PreparedStatements that are only prepared once for performance. Each record in your data list is bound to the same PreparedStatement, then executed asynchronously for high performance.

[source,java]
----
String cqlIngest = "insert into person (id, name, age) values (?, ?, ?)";

List<Object> person1 = new ArrayList<Object>();
person1.add("10000");
person1.add("David");
person1.add(40);

List<Object> person2 = new ArrayList<Object>();
person2.add("10001");
person2.add("Roger");
person2.add(65);

List<List<?>> people = new ArrayList<List<?>>();
people.add(person1);
people.add(person2);

cassandraOperations.ingest(cqlIngest, people);
----

[[cassandra-template-update]]
=== Updating rows in a CQL table

Much like inserting, there are several flavors of update from which you can choose.

Update a record with an annotated POJO.

[source,java]
----
cassandraOperations.update(new Person("123123123", "Alison", 35));
----

Update a row using the QueryBuilder.Update object that is part of the DataStax Java Driver.

[source,java]
----
Update update = QueryBuilder.update("person");
update.setConsistencyLevel(ConsistencyLevel.ONE);
update.with(QueryBuilder.set("age", 35));
update.where(QueryBuilder.eq("id", "123123123"));

cassandraOperations.execute(update);
----

Then there is always the old fashioned way. You can write your own CQL statements.

[source,java]
----
String cql = "update person set age = 35 where id = '123123123'";

cassandraOperations.execute(cql);
----

[[cassandra-template.delete]]
=== Methods for removing rows

Much like inserting, there are several flavors of delete from which you can choose.

Delete a record with an annotated POJO.

[source,java]
----
cassandraOperations.delete(new Person("123123123", null, 0));
----

Delete a row using the QueryBuilder.Delete object that is part of the DataStax Java Driver.

[source,java]
----
Delete delete = QueryBuilder.delete().from("person");
delete.where(QueryBuilder.eq("id", "123123123"));

cassandraOperations.execute(delete);
----

Then there is always the old fashioned way. You can write your own CQL statements.

[source,java]
----
String cql = "delete from person where id = '123123123'";

cassandraOperations.execute(cql);
----

=== Methods for truncating tables

Much like inserting, there are several flavors of truncate from which you can choose.

Truncate a table using the truncate() method.

[source,java]
----
cassandraOperations.truncate("person");
----

Truncate a table using the QueryBuilder.Truncate object that is part of the DataStax Java Driver.

[source,java]
----
Truncate truncate = QueryBuilder.truncate("person");

cassandraOperations.execute(truncate);
----

Then there is always the old fashioned way. You can write your own CQL statements.

[source,java]
----
String cql = "truncate person";

cassandraOperations.execute(cql);
----

[[cassandra.query]]
== Querying CQL Tables

Tthere are several flavors of select and query from which you can choose. Please see the CassandraTemplate API documentation for all overloads available.

Query a table for multiple rows and map the results to a POJO.

[source,java]
----
String cqlAll = "select * from person";

List<Person> results = cassandraOperations.select(cqlAll, Person.class);
for (Person p : results) {
  LOG.info(String.format("Found People with Name [%s] for id [%s]", p.getName(), p.getId()));
}
----

Query a table for a single row and map the result to a POJO.

[source,java]
----
String cqlOne = "select * from person where id = '123123123'";

Person p = cassandraOperations.selectOne(cqlOne, Person.class);
LOG.info(String.format("Found Person with Name [%s] for id [%s]", p.getName(), p.getId()));
----

Query a table using the QueryBuilder.Select object that is part of the DataStax Java Driver.

[source,java]
----
Select select = QueryBuilder.select().from("person");
select.where(QueryBuilder.eq("id", "123123123"));

Person p = cassandraOperations.selectOne(select, Person.class);
LOG.info(String.format("Found Person with Name [%s] for id [%s]", p.getName(), p.getId()));
----

Then there is always the old fashioned way. You can write your own CQL statements, and there are several callback handlers for mapping the results. The example uses the RowMapper interface.

[source,java]
----
String cqlAll = "select * from person";
List<Person> results = cassandraOperations.query(cqlAll, new RowMapper<Person>() {

	public Person mapRow(Row row, int rowNum) throws DriverException {
		Person p = new Person(row.getString("id"), row.getString("name"), row.getInt("age"));
		return p;
	}
});

for (Person p : results) {
	LOG.info(String.format("Found People with Name [%s] for id [%s]", p.getName(), p.getId()));
}
----

[[cassandra.custom-converters]]
== Overriding default mapping with custom converters

In order to have more fine grained control over the mapping process you can register Spring converters with the `CassandraConverter` implementations such as the `MappingCassandraConverter`.

The `MappingCassandraConverter` checks to see if there are any Spring converters that can handle a specific class before attempting to map the object itself. To 'hijack' the normal mapping strategies of the `MappingCassandraConverter`, perhaps for increased performance or other custom mapping needs, you first need to create an implementation of the Spring `Converter` interface and then register it with the MappingConverter.

NOTE: For more information on the Spring type conversion service see the reference docs http://docs.spring.io/spring/docs/current/spring-framework-reference/html/validation.html#core-convert[here].

[[cassandra.custom-converters.writer]]
=== Saving using a registered Spring Converter

An example implementation of the `Converter` that converts a `Person` object to a `java.lang.String` using Jackson 2 is shown below:

[source,java]
----
import org.springframework.core.convert.converter.Converter;

import org.springframework.util.StringUtils;
import org.codehaus.jackson.map.ObjectMapper;

static class PersonWriteConverter implements Converter<Person, String> {

  public String convert(Person source) {

    try {
      return new ObjectMapper().writeValueAsString(source);
    } catch (IOException e) {
      throw new IllegalStateException(e);
    }
  }
}
----

[[cassandra.custom-converters.reader]]
=== Reading using a Spring Converter

An example implementation of the `Converter` that converts a `java.lang.String` into a `Person` object using Jackson 2 is shown below:

[source,java]
----
import org.springframework.core.convert.converter.Converter;

import org.springframework.util.StringUtils;
import org.codehaus.jackson.map.ObjectMapper;

static class PersonReadConverter implements Converter<String, Person> {

  public Person convert(String source) {

   if (StringUtils.hasText(source)) {
     try {
       return new ObjectMapper().readValue(source, Person.class);
     } catch (IOException e) {
       throw new IllegalStateException(e);
     }
    }

    return null;
  }
}
----

[[cassandra.custom-converters.java]]
=== Registering Spring Converters with the CassandraConverter

The Spring Data Cassandra Java Config provides a convenient way to register Spring `Converter` s with the `MappingCassandraConverter`. The configuration snippet below shows how to manually register converters as well as configuring the `CustomConversions`.

[source,java]
----
@Configuration
public static class Config extends AbstractCassandraConfiguration {

  @Override
  public CustomConversions customConversions() {

    List<Converter<?, ?>> converters = new ArrayList<Converter<?, ?>>();
    converters.add(new PersonReadConverter());
    converters.add(new PersonWriteConverter());

    return new CustomConversions(converters);
  }

  // other methods omitted...
}
----

[[cassandra.converter-disambiguation]]
=== Converter disambiguation

Generally we inspect the `Converter` implementations for the source and target types they convert from and to. Depending on whether one of those is a type Cassandra can handle natively we will register the converter instance as reading or writing one. Have a look at the following samples:

[source,java]
----
// Write converter as only the target type is one cassandra can handle natively
class MyConverter implements Converter<Person, String> { … }

// Read converter as only the source type is one cassandra can handle natively
class MyConverter implements Converter<String, Person> { … }
----

In case you write a `Converter` whose source and target type are native cassandra types there's no way for us to determine whether we should consider it as reading or writing converter. Registering the converter instance as both might lead to unwanted results then. E.g. a `Converter<String, Long>` is ambiguous although it probably does not make sense to try to convert all `String` instances into `Long` instances when writing. To be generally able to force the infrastructure to register a converter for one way only we provide `@ReadingConverter` as well as `@WritingConverter` to be used at the converter implementation.

[[cassandra-template.commands]]
== Executing Commands

[[cassandra-template.commands.execution]]
=== Methods for executing commands

The CassandraTemplate has many overloads for execute() and executeAsync(). Pass in the CQL command you wish to be executed, and handle the appropriate response.

This example uses the basic AsynchronousQueryListener that comes with Spring Data Cassandra. Please see the API documentation for all the options. There should be nothing you cannot perform in Cassandra with the execute() and executeAsync() methods.

[source,java]
----
cassandraOperations.executeAsynchronously("delete from person where id = '123123123'",
		new AsynchronousQueryListener() {

			public void onQueryComplete(ResultSetFuture rsf) {
				LOG.info("Async Query Completed");
			}
		});
----

This example shows how to create and drop a table, using different API objects, all passed to the execute() methods.

[source]
----
cassandraOperations.execute("create table test_table (id uuid primary key, event text)");

DropTableSpecification dropper = DropTableSpecification.dropTable("test_table");
cassandraOperations.execute(dropper);
----

[[cassandra.exception]]
== Exception Translation

The Spring framework provides exception translation for a wide variety of database and mapping technologies. This has traditionally been for JDBC and JPA. The Spring support for Cassandra extends this feature to Cassandra by providing an implementation of the `org.springframework.dao.support.PersistenceExceptionTranslator` interface.

The motivation behind mapping to Spring's http://docs.spring.io/spring/docs/current/spring-framework-reference/html/dao.html#dao-exceptions[consistent data access exception hierarchy] is that you are then able to write portable and descriptive exception handling code without resorting to coding against Cassandra Exceptions. All of Spring's data access exceptions are inherited from the root `DataAccessException` class so you can be sure that you will be able to catch all database related exception within a single try-catch block.

